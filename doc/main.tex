% !TEX program = xelatex
\documentclass[12pt,openright]{report}
\usepackage{geometry}
\usepackage{titlesec}
\usepackage{graphicx}
\usepackage{fontspec}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{etoolbox}
\usepackage{microtype}
\usepackage[hidelinks]{hyperref}
\usepackage[polish]{babel}

\BeforeBeginEnvironment{lstlisting}{\begin{minipage}{\linewidth}}
\AfterEndEnvironment{lstlisting}{\end{minipage}}

\widowpenalty=10000
\clubpenalty=10000

\frenchspacing
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt}
\geometry{
    top=2.5cm,
    bottom=2.5cm,
    left=3cm,
    right=2.5cm
}

\lstdefinelanguage{TypeScript}{
  keywords={break, case, catch, class, const, continue, debugger, default, delete, do, else, enum, export, extends, false, finally, for, function, if, import, in, instanceof, new, null, return, super, switch, this, throw, true, try, typeof, var, while, with, let, static, yield, await},
  keywordstyle=\color{blue},
  sensitive=true,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{green!60!black},
  stringstyle=\color{red},
  morestring=[b]',
  morestring=[b]"
}

\lstdefinelanguage{tsx}{
  keywords={const, let, var, function, return, if, else, for, while, do, switch, case, break, continue, import, export, default, from, as, class, extends, new, this, super, interface, type},
  keywordstyle=\color{blue},
  sensitive=true,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{green!60!black},
  stringstyle=\color{red},
  morestring=[b]',
  morestring=[b]",
  morestring=[b]`,
  basicstyle=\ttfamily\small,
  identifierstyle=\color{black},
  morekeywords=[2]{div, span, p, a, img, ul, li, button, input, form, label, h1, h2, h3, h4, h5, h6, header, footer, main, nav, section, article, aside, textarea, select, option, canvas, svg},
  keywordstyle=[2]\color{purple},
  morekeywords=[3]{style, onClick, onChange, id, className, src, alt, href, value, type},
  keywordstyle=[3]\color{orange},
  morekeywords=[4]{string, number, boolean, any, void, null, undefined},
  keywordstyle=[4]\color{blue!60}
}

\lstset{
    frame=single,
    breaklines=true,
    columns=flexible,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue},
    commentstyle=\color{green!60!black},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny\color{gray},
    numbersep=5pt,
    tabsize=2,
    showstringspaces=false,
    extendedchars=true,
    inputencoding=utf8,
    keepspaces=true,
    literate={ą}{ą}1 {ć}{ć}1 {ę}{ę}1 {ł}{ł}1 {ń}{ń}1 {ó}{ó}1 {ś}{ś}1 {ź}{ź}1 {ż}{ż}1
             {Ą}{Ą}1 {Ć}{Ć}1 {Ę}{Ę}1 {Ł}{Ł}1 {Ń}{Ń}1 {Ó}{Ó}1 {Ś}{Ś}1 {Ź}{Ź}1 {Ż}{Ż}1
}

\setmainfont{Times New Roman}
\setmonofont{Courier New}

\begin{document}

\begin{titlepage}
    \begin{center}
        \large
        Uniwersytet WSB Merito w Poznaniu\\
        Wydział Zamiejscowy w Chorzowie \\

        \vspace{2cm}
        \large
        Jakub Kielaszek \\

        \vspace{2cm}
        \LARGE
        \textbf{Architektura i optymalizacja renderowania w aplikacjach webowych na przykładzie wizualizera algorytmów sortowania}\\

        \vspace{2cm}
        \large
        \textbf{Projekt dyplomowy}\\
    \end{center}

    \vspace{2cm}
    \begin{flushright}
        \large
        \textbf{Kierownik naukowy:}\\
        \textbf{dr Tomasz Staś}\\
    \end{flushright}

    \vspace{2cm}
    \begin{flushleft}
        \Large
        \textbf{Kierunek:} Informatyka\\
        \textbf{Specjalność:} Zaawansowane systemy baz danych\\
    \end{flushleft}

    \vspace{1cm}
    \begin{center}
        \large
        CHORZÓW 2026
    \end{center}
\end{titlepage}


\pagenumbering{roman}
\section*{Streszczenie}
\addcontentsline{toc}{chapter}{Streszczenie}


\tableofcontents
\pagenumbering{arabic}
\setcounter{page}{1}

\chapter*{Wstęp}
\addcontentsline{toc}{chapter}{Wstęp}
Dynamiczny rozwój technologii internetowych oraz rosnące oczekiwania użytkowników wobec szybkości, interaktywności i responsywności aplikacji webowych sprawiają, że wydajność renderowania staje się jednym z kluczowych wyzwań współczesnego frontendu. Wraz z ewolucją od prostych, statycznych stron HTML do wysoce złożonych aplikacji jednosesyjnych (SPA), znacząco wzrosła zarówno złożoność logiki interfejsu użytkownika, jak i liczba aktualizacji widoku wykonywanych w bardzo krótkich interwałach czasowych. W tym kontekście kluczowego znaczenia nabierają nowoczesne frameworki frontendowe, takie jak React oraz Angular, które, mimo wspólnego celu, oferują fundamentalnie odmienne podejścia architektoniczne i mechanizmy synchronizacji stanu z modelem dokumentu (DOM). Zrozumienie tych różnic jest niezbędne nie tylko z punktu widoku teoretycznego, ale przede wszystkim dla inżynierów oprogramowania dążących do budowy skalowalnych i wydajnych systemów webowych.

Rosnąca złożoność współczesnych aplikacji frontendowych wynika z przenoszenia coraz większej liczby operacji z warstwy serwerowej bezpośrednio do przeglądarki klienta. Mechanizmy takie jak dynamiczne komponenty, rozbudowane drzewa zależności stanu, interaktywne animacje czy obsługa danych w czasie rzeczywistym wymagają wysokowydajnych metod aktualizacji widoku. React i Angular podchodzą do tych wyzwań w różny sposób: React opiera się na deklaratywnym modelu komponentów i mechanizmie wirtualnego drzewa widoku (Virtual DOM), podczas gdy Angular implementuje kompleksową architekturę z silnym systemem wstrzykiwania zależności oraz strukturalnym podejściem do detekcji zmian. Wybór między tymi technologiami często determinuje nie tylko wydajność końcową produktu, ale także ergonomię pracy deweloperów oraz łatwość utrzymania kodu w długim terminie.

Celem niniejszej pracy jest przeprowadzenie dogłębnej analizy i porównania podejść do renderowania interfejsu użytkownika w frameworkach React i Angular, ze szczególnym uwzględnieniem aspektów wydajnościowych, architektonicznych oraz ergonomii programistycznej. Wybór wizualizatora algorytmów sortowania jako głównego studium przypadku podyktowany jest specyfiką tego rodzaju aplikacji — wymagają one bardzo wysokiej częstotliwości aktualizacji widoku przy jednoczesnej manipulacji dużą liczbą elementów graficznych. Każda operacja zamiany elementów lub ich porównania generuje zdarzenie, które musi zostać odzwierciedlone w modelu dokumentu, co stawia ekstremalne wymagania przed mechanizmami detekcji zmian i procesem reconciliation. Taka charakterystyka pracy pozwala na precyzyjne przetestowanie granic wydajności silników renderujących oraz mechanizmów detekcji zmian w obu technologiach.

W pracy przygotowano autorski wizualizator algorytmów sortowania, zaimplementowany równolegle w obu technologiach. Ma on służyć jako platforma badawcza do systematycznego i porównywalnego testowania efektywności renderowania, zużycia zasobów procesora oraz płynności interfejsu podczas intensywnych operacji na danych. Wizualizacja procesów algorytmicznych w czasie rzeczywistym jest wyzwaniem nie tylko ze względu na liczbę operacji DOM, ale także konieczność zachowania wysokiej częstotliwości odświeżania (FPS), co bezpośrednio przekłada się na percepcję płynności ruchu przez użytkownika. Dzięki temu możliwe jest sformułowanie merytorycznych wniosków dotyczących mocnych i słabych stron przeanalizowanych frameworków w kontekście nowoczesnych, wysokowydajnych aplikacji frontendowych.

Cele szczegółowe pracy obejmują:

\begin{itemize}

\item przygotowanie szczegółowego przeglądu architektury oraz kluczowych mechanizmów działania frameworków React i Angular,

\item opracowanie i implementację wizualizatora algorytmów sortowania w obu technologiach przy zachowaniu identycznych założeń funkcjonalnych,

\item identyfikację i analizę zaawansowanych technik optymalizacji renderowania specyficznych dla każdej z technologii,

\item przeprowadzenie pomiarów wydajnościowych i ocenę ich wpływu na płynność interfejsu oraz stabilność aplikacji,

\item porównanie złożoności implementacyjnej, czytelności kodu oraz ogólnej ergonomii pracy programisty w obu ekosystemach,

\item sformułowanie rekomendacji technologicznych dla projektów wymagających intensywnego przetwarzania i wizualizacji danych.

\end{itemize}

Zakres pracy koncentruje się na analizie porównawczej mechanizmów renderowania i aktualizacji interfejsu w React oraz Angular. Część praktyczna skupia się na implementacji wizualizatora, który stanowi wspólny mianownik dla testów wydajnościowych. Praca nie porusza zagadnień związanych z architekturą backendową, bezpieczeństwem przesyłu danych ani optymalizacją po stronie serwera (SSR), skupiając się wyłącznie na warstwie prezentacji i logice wykonywanej w przeglądarce.

Praca składa się z czterech zasadniczych rozdziałów. W rozdziale pierwszym przedstawiono fundamenty teoretyczne, ewolucję aplikacji webowych oraz charakterystykę analizowanych frameworków. Rozdział drugi opisuje przyjętą metodykę badań oraz proces implementacji platformy testowej. W trzecim rozdziale zaprezentowano i przeanalizowano wyniki pomiarów wydajnościowych oraz porównanie produktywności. Pracę kończy rozdział czwarty, zawierający syntezę wyników, wnioski końcowe oraz rekomendacje dla inżynierów i architektów oprogramowania.

\chapter{Podstawy teoretyczne i przegląd technologii frontendowych}
Podstawy teoretyczne stanowią istotny fundament dla dalszej części pracy, obejmującej analizę architektury oraz mechanizmów działania nowoczesnych frameworków frontendowych. W rozdziale przedstawiono ewolucję aplikacji webowych oraz omówiono najważniejsze koncepcje związane z ich tworzeniem, ze szczególnym uwzględnieniem współczesnych paradygmatów i modeli programowania w JavaScripcie. Kolejne podsekcje prezentują przegląd dwóch popularnych technologii — React i Angular — wraz z ich kluczowymi założeniami architektonicznymi i podejściami do renderowania interfejsu użytkownika. Rozdział kończy omówienie podstaw algorytmów sortowania oraz metod ich wizualizacji, co stanowi kontekst dla implementacji aplikacji prezentowanych w dalszej części pracy.

\section{Ewolucja i znaczenie nowoczesnych aplikacji webowych}
Początki aplikacji webowych sięgają statycznych stron HTML, które pełniły funkcję prostych dokumentów prezentowanych użytkownikowi bez możliwości interakcji. W modelu tym cała logika przetwarzania danych oraz generowania treści znajdowała się po stronie serwera, natomiast przeglądarka pełniła wyłącznie rolę klienta wyświetlającego przygotowaną wcześniej zawartość. Tego typu podejście było wystarczające w czasach niskich wymagań funkcjonalnych, jednak wraz z rosnącą popularnością internetu i pojawieniem się bardziej złożonych serwisów zaczęło okazywać się niewystarczające.

Kolejnym etapem rozwoju było wprowadzenie mechanizmów dynamicznego generowania stron oraz technologii takich jak JavaScript i AJAX, które umożliwiły odświeżanie wybranych fragmentów interfejsu bez konieczności przeładowywania całej strony. Pozwoliło to na stworzenie bardziej interaktywnych aplikacji oraz znacząco poprawiło komfort użytkownika. Wraz z tymi zmianami zaczęły pojawiać się pierwsze rozwiązania nakierowane na organizację kodu po stronie klienta, a także frameworki wspierające tworzenie modularnych komponentów interfejsu.

Dynamiczny rozwój technologii frontendowych doprowadził do powstania aplikacji jednosesyjnych (Single Page Applications, SPA), które stanowią obecnie dominujący model budowy interfejsów webowych. SPA charakteryzują się tym, że cała aplikacja jest ładowana jednorazowo, a kolejne interakcje użytkownika prowadzą do aktualizacji tylko tych elementów, które faktycznie ulegają zmianie. Przeniesienie znacznej części logiki na stronę klienta wymusiło jednak opracowanie bardziej zaawansowanych mechanizmów zarządzania stanem oraz aktualizacji widoku, ponieważ rosnąca złożoność komponentów oraz liczba zmian w ich stanie stawiały wysokie wymagania dotyczące efektywności renderowania.

W tym kontekście istotnego znaczenia nabrały nowoczesne frameworki frontendowe, takie jak React i Angular, które proponują odmienne podejścia architektoniczne do organizacji kodu, zarządzania stanem oraz aktualizacji interfejsu użytkownika. React, oparty na koncepcji deklaratywnego programowania i wykorzystaniu wirtualnego drzewa DOM, znacząco zmienił sposób myślenia o komponowaniu interfejsu oraz odświeżaniu widoku. Angular natomiast rozwija architekturę opartą na komponentach, modułach i mechanizmach detekcji zmian, zapewniając ustrukturyzowane środowisko do tworzenia rozbudowanych aplikacji o dużej skali.

Równocześnie użytkownicy zaczęli oczekiwać od aplikacji webowych płynności i jakości działania porównywalnych z natywnymi aplikacjami mobilnymi czy desktopowymi. Oznacza to konieczność minimalizacji opóźnień, redukcji liczby niepotrzebnych renderów oraz optymalnego zarządzania stanem aplikacji. Wydajność renderowania stała się więc kluczowym aspektem doświadczenia użytkownika, a jednocześnie jednym z najważniejszych kryteriów przy wyborze technologii frontendowych. Zbiór metryk takich jak \textit{Core Web Vitals} pozwala na obiektywną ocenę jakości interakcji użytkownika z witryną \cite{Web_Vitals}. W wielu współczesnych projektach to właśnie sposób aktualizacji interfejsu oraz efektywność wykonywania operacji renderujących wpływają na ogólną jakość aplikacji, jej skalowalność oraz koszty utrzymania.

Znaczenie nowoczesnych aplikacji webowych wykracza poza typowe strony internetowe — obejmuje systemy biznesowe, narzędzia analityczne, aplikacje edukacyjne, panele administracyjne, a także interaktywne wizualizacje danych. W tych zastosowaniach renderowanie elementów interfejsu często odbywa się wielokrotnie w krótkich odstępach czasu, co zwiększa potrzebę stosowania wydajnych mechanizmów aktualizacji widoku. Z tego względu zrozumienie różnic pomiędzy podejściami oferowanymi przez React i Angular jest istotne nie tylko z perspektywy teoretycznej, ale również praktycznej i projektowej.

Podsumowując, rozwój aplikacji webowych od prostych stron HTML do rozbudowanych aplikacji jednosesyjnych znacząco wpłynął na sposób projektowania i implementacji interfejsów użytkownika. Wzrost złożoności logiki po stronie klienta oraz potrzeba częstych aktualizacji widoku sprawiły, że optymalizacja renderowania stała się jednym z najważniejszych wyzwań współczesnego frontendu. Frameworki React i Angular stanowią dwa dominujące podejścia do jego rozwiązania, co czyni ich analizę istotną zarówno z perspektywy inżynierskiej, jak i praktycznej.

\section{JavaScript i TypeScript we współczesnym ekosystemie frontendu}
JavaScript jest podstawowym językiem programowania wykorzystywanym do tworzenia interfejsów użytkownika w aplikacjach webowych. Jego rola stopniowo rosła wraz z ewolucją witryn internetowych od prostych stron statycznych do nowoczesnych aplikacji jednosesyjnych, wymagających dynamicznych aktualizacji widoku oraz częstej komunikacji z serwerem. JavaScript jest językiem interpretowanym, uruchamianym bezpośrednio w przeglądarce, co umożliwia tworzenie interaktywnych elementów oraz reagowanie na zdarzenia użytkownika, takie jak kliknięcia czy zmiany danych wejściowych. Kluczowym mechanizmem pozwalającym na sprawne działanie aplikacji jest model jednowątkowy oparty na pętli zdarzeń (ang. event loop), który umożliwia asynchroniczne przetwarzanie operacji bez blokowania interfejsu użytkownika.

Istotny wpływ na rozwój JavaScriptu miało wprowadzenie standardu ECMAScript 6 (ES6), który rozbudował język o nowoczesne mechanizmy wspierające programowanie strukturalne i modularne. Do najważniejszych rozszerzeń należą moduły import/export, klasy, funkcje strzałkowe oraz usprawnione zarządzanie zmiennymi poprzez \texttt{let} i \texttt{const}. Zmiany te umożliwiły budowanie bardziej przejrzystych projektów, poprawiły czytelność kodu oraz zwiększyły skalowalność aplikacji. Współczesne frameworki frontendowe, takie jak React i Angular, ściśle opierają się na funkcjonalnościach ES6 i nowszych wersji ECMAScript, wykorzystując je do implementacji architektury komponentowej, obsługi stanu oraz mechanizmów aktualizacji widoku.

Drugim kluczowym elementem ekosystemu frontendowego jest TypeScript — nadzbiór JavaScriptu opracowany przez Microsoft, wprowadzający statyczne typowanie oraz szereg mechanizmów znanych z języków obiektowych. TypeScript pozwala na definiowanie typów zmiennych, struktur danych, interfejsów oraz klas, co znacząco zwiększa bezpieczeństwo i przewidywalność kodu, szczególnie w dużych projektach. Kompilacja TypeScriptu do JavaScriptu umożliwia korzystanie z rozszerzeń typów bez rezygnacji z kompatybilności z przeglądarkami.

TypeScript odgrywa szczególnie ważną rolę w Angularze, który został zaprojektowany w pełnej integracji z typowaniem statycznym. Dzięki temu architektura Angulara opiera się na klasach, dekoratorach, wstrzykiwaniu zależności oraz modułach, a statyczne typowanie wspiera analizę błędów jeszcze przed uruchomieniem aplikacji. React z kolei w naturalny sposób wspiera TypeScript, choć nie jest od niego zależny — jednak w praktyce większość nowych projektów React powstaje właśnie z użyciem TypeScriptu ze względu na większą czytelność i bezpieczeństwo kodu.

Zarówno JavaScript, jak i TypeScript stanowią fundament rozwoju nowoczesnych narzędzi frontendowych, umożliwiając tworzenie skalowalnych, modularnych i wydajnych aplikacji webowych. Zrozumienie ich kluczowych mechanizmów, takich jak model zdarzeń, moduły ES6, klasy oraz statyczne typowanie, jest niezbędne dla analizy architektury oraz sposobu działania frameworków React i Angular, omówionych w następnych podsekcjach.

\section{Przegląd paradygmatów i architektury frameworków TypeScript}
Rozwój nowoczesnych frameworków JavaScript wynika bezpośrednio z rosnącej złożoności aplikacji webowych oraz potrzeby stosowania bardziej ustrukturyzowanych metod organizacji kodu po stronie klienta. Wraz z upowszechnieniem się aplikacji jednosesyjnych pojawiło się zapotrzebowanie na narzędzia, które umożliwiałyby efektywne zarządzanie stanem, modularność, ponowne wykorzystanie komponentów oraz kontrolę nad procesem renderowania interfejsu. W odpowiedzi na te potrzeby powstały liczne biblioteki i frameworki frontendowe, reprezentujące odmienne paradygmaty projektowania i przetwarzania danych w kontekście interfejsu użytkownika.

Jednym z kluczowych paradygmatów, który znacząco wpłynął na sposób budowania interfejsów webowych, jest programowanie komponentowe. Zakłada ono podział aplikacji na małe, niezależne moduły odpowiedzialne za określone fragmenty logiki i widoku. Każdy komponent może definiować swój stan, metody oraz sposób wyświetlania, a następnie być wielokrotnie wykorzystywany w różnych częściach aplikacji. Komponentowe podejście umożliwia przejrzystą strukturę projektu, ułatwia testowanie oraz zwiększa skalowalność, szczególnie w aplikacjach obsługujących dużą liczbę dynamicznych elementów.

Innym istotnym paradygmatem jest programowanie deklaratywne, charakterystyczne przede wszystkim dla Reacta. W podejściu deklaratywnym programista opisuje, jaki stan interfejs ma zostać wyświetlony dla określonych danych, natomiast szczegóły dotyczące aktualizacji, renderowania i synchronizacji widoku z logiką wewnętrzną są ukryte za mechanizmami frameworka. Dzięki temu zmniejsza się liczba błędów wynikających z ręcznego manipulowania DOM, a kod staje się bardziej przewidywalny i łatwiejszy do analizy.

Angular natomiast łączy elementy podejścia deklaratywnego z architekturą opartą na wzorcu MVVM oraz mechanizmem wstrzykiwania zależności, co umożliwia ścisłe rozdzielenie warstw logiki biznesowej, widoku oraz komunikacji z usługami. Duży nacisk położony jest na strukturalność projektu, wykorzystanie modułów oraz silną typizację dzięki integracji z TypeScript. Takie podejście jest szczególnie korzystne w projektach o dużej skali, gdzie kluczowa jest czytelna organizacja kodu i jego łatwa rozbudowa w przyszłości.

Wspólną cechą większości współczesnych frameworków JavaScript jest dążenie do minimalizacji kosztów związanych z aktualizacją widoku. Mechanizmy takie jak Virtual DOM w React, strefy i detekcja zmian w Angularze, reaktywny przepływ danych czy zaawansowane modele kolejkowania operacji renderujących zostały zaprojektowane po to, aby unikać niepotrzebnych odświeżeń interfejsu. Dzięki temu możliwe jest budowanie aplikacji reagujących na częste zmiany stanu i przetwarzających duże ilości danych przy zachowaniu płynnej i stabilnej pracy.

Paradygmaty i architektury wykorzystywane przez współczesne frameworki mają bezpośredni wpływ na wydajność aplikacji oraz wygodę pracy programisty. Różnice w sposobie zarządzania stanem, obsługi cyklu życia komponentów oraz reagowania na zmiany danych sprawiają, że React i Angular sprawdzają się inaczej w zależności od charakteru projektu i wymagań użytkownika. Zrozumienie tych podejść jest kluczowe dla dalszej analizy technik renderowania oraz porównania obu frameworków w kontekście implementacji wizualizatora algorytmów \mbox{sortowania}.

\section{Charakterystyka React}
React jest jedną z najpopularniejszych bibliotek frontendowych wykorzystywanych do budowy interfejsów użytkownika we współczesnych aplikacjach webowych. Został opracowany przez Facebooka w 2013 roku jako odpowiedź na rosnącą złożoność warstwy prezentacji w dużych systemach internetowych oraz potrzebę efektywnego zarządzania licznymi aktualizacjami widoku. React szybko zyskał szerokie zastosowanie w przemyśle dzięki swojej prostocie, modularności oraz nowatorskiemu podejściu do renderowania komponentów.

Podstawą Reacta jest deklaratywny model programowania, w którym programista opisuje, jak interfejs ma wyglądać dla określonego stanu danych, zamiast zarządzać ręcznie operacjami modyfikującymi DOM. Dzięki temu kod jest bardziej przewidywalny, łatwiejszy do utrzymania oraz mniej podatny na błędy związane z ręczną manipulacją strukturą dokumentu. Kluczowym elementem działania Reacta jest również wykorzystanie koncepcji Virtual DOM — lekkiej reprezentacji drzewa elementów, pozwalającej na efektywne określanie minimalnego zakresu zmian potrzebnych do zaktualizowania widoku.

React wprowadza komponentową strukturę aplikacji, w której interfejs podzielony jest na niewielkie, niezależne moduły odpowiadające za określoną funkcjonalność lub fragment widoku. Każdy komponent może posiadać stan lokalny, reagować na zmiany danych oraz uczestniczyć w przepływie informacji w aplikacji. Taki sposób organizacji sprzyja modularności, ponownemu wykorzystaniu kodu oraz tworzeniu aplikacji o wysokiej skalowalności.

Z perspektywy wydajności istotne znaczenie ma mechanizm ponownego renderowania komponentów, który w React może być optymalizowany poprzez odpowiednie zarządzanie zmianami stanu oraz właściwą organizację struktury komponentowej. Wprowadzenie hooków, takich jak \textit{useState}, \textit{useEffect} czy \textit{useMemo}, umożliwiło bardziej elastyczne zarządzanie cyklem życia komponentów oraz kontrolę nad tym, kiedy i dlaczego następuje ponowne renderowanie. React dostarcza również narzędzia wspierające analizę wydajności, takie jak profiler, co ułatwia identyfikowanie komponentów generujących nadmiarowe odświeżenia.

Zastosowanie Reacta w aplikacjach wymagających częstych aktualizacji interfejsu — takich jak wizualizatory danych czy systemy czasu rzeczywistego — jest szczególnie interesujące ze względu na sposób, w jaki biblioteka zarządza aktualizacjami widoku. Właśnie tego typu zastosowania pozwalają na praktyczną ocenę efektywności mechanizmów renderowania oraz wpływu architektury biblioteki na płynność działania interfejsu użytkownika.

\subsection{Architektura i kluczowe koncepcje}
Architektura React opiera się na kilku fundamentalnych koncepcjach, które definiują sposób budowy interfejsu użytkownika oraz zarządzania jego aktualizacjami. Najważniejszym z nich jest komponentowy model aplikacji, który zakłada podział interfejsu na niezależne, wielokrotnie wykorzystywane elementy. Komponent może reprezentować zarówno niewielki fragment widoku, jak i bardziej złożoną strukturę składającą się z wielu podkomponentów. Dzięki temu kod aplikacji staje się modularny, łatwiejszy do utrzymania oraz podatny na skalowanie.

Kolejną kluczową koncepcją Reacta jest deklaratywny sposób definiowania interfejsu użytkownika. Programista opisuje, jak interfejs ma wyglądać dla określonego stanu danych, natomiast React odpowiada za minimalną liczbę operacji aktualizujących rzeczywisty DOM. Deklaratywność sprawia, że kod jest bardziej przejrzysty i mniej podatny na błędy wynikające z ręcznego manipulowania drzewem DOM, charakterystycznego dla wcześniejszych rozwiązań opartych na podejściu imperatywnym.

React wykorzystuje również własne rozszerzenie składni JavaScript, znane jako JSX (JavaScript XML). JSX umożliwia opisywanie struktury komponentów w sposób zbliżony do HTML, a jednocześnie pozwala na osadzanie logiki JavaScript bezpośrednio w definicji widoku. Rozwiązanie to zwiększa czytelność kodu oraz ułatwia łączenie warstwy prezentacji z logiką aplikacji, co jest szczególnie korzystne w przypadku dynamicznych interfejsów wymagających częstych aktualizacji.

Fundamentem wydajności Reacta jest mechanizm Virtual DOM. Jest to lekka reprezentacja drzewa elementów, która przechowuje zapisaną w pamięci strukturę interfejsu. W momencie zmiany stanu komponentu React generuje nowe drzewo Virtual DOM, a następnie porównuje je z poprzednią wersją, aby określić, które elementy interfejsu faktycznie uległy zmianie. Dzięki temu liczba operacji wykonywanych na prawdziwym DOM jest znacząco zredukowana, co wpływa na zwiększenie wydajności renderowania, szczególnie w przypadku aplikacji wymagających częstych odświeżeń widoku.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{images/react-dom.png}
    \caption{Schemat procesu aktualizacji Virtual DOM i rzeczywistego DOM w React.}
    \label{fig:react-vdom}
\end{figure}

Wraz z wprowadzeniem architektury React Fiber przebudowano wewnętrzny mechanizm odpowiedzialny za przetwarzanie aktualizacji komponentów. Fiber stanowi asynchroniczny, priorytetowy model renderowania, który umożliwia dzielenie procesu odświeżania na mniejsze części oraz nadawanie priorytetów poszczególnym aktualizacjom \cite{React_Concurrent_Docs}. Dzięki temu React może bardziej efektywnie reagować na interakcje użytkownika oraz zapewniać płynność działania nawet wtedy, gdy aplikacja wykonuje złożone operacje w tle.

Istotnym elementem architektury Reacta jest również cykl życia komponentów, który definiuje, w jakich momentach aplikacja może odwołać się do logiki zewnętrznej lub wykonać działania związane z odświeżaniem widoku. Wraz z wprowadzeniem hooków cykl życia został uproszczony i ujednolicony, co znacząco zwiększyło elastyczność zarządzania stanem oraz zachowaniami komponentów. Hooki, takie jak \textit{useState}, \textit{useEffect} czy \textit{useRef}, pozwalają na precyzyjne kontrolowanie efektów ubocznych, aktualizacji stanu oraz interakcji z elementami DOM.

Podsumowując, architektura Reacta opiera się na czytelnej strukturze komponentów, deklaratywnym opisie interfejsu oraz efektywnym modelu aktualizacji widoku opartym na Virtual DOM i mechanizmie Fiber. Rozwiązania te umożliwiają tworzenie aplikacji o wysokiej wydajności i dużej skalowalności, a jednocześnie zapewniają elastyczność programistyczną i przejrzystość kodu, co czyni React jednym z najpopularniejszych rozwiązań we współczesnym ekosystemie frontendowym.
\subsection{Zarządzanie stanem w React}
Zarządzanie stanem jest jednym z kluczowych elementów programowania w React, ponieważ to właśnie stan decyduje o tym, jakie dane są prezentowane w interfejsie oraz kiedy konieczne jest jego ponowne odświeżenie. React opiera się na koncepcji jednokierunkowego przepływu danych (ang. unidirectional data flow), zgodnie z którą dane przepływają w dół struktury komponentów, od komponentów nadrzędnych do podrzędnych. Takie podejście zwiększa przewidywalność aplikacji i ułatwia analizę zmian zachodzących w interfejsie.

Podstawowym narzędziem do zarządzania stanem w komponentach funkcjonalnych jest hook useState, który umożliwia przechowywanie oraz aktualizację lokalnego stanu komponentu. Zmiana wartości stanu powoduje ponowne renderowanie komponentu, a React dba o to, aby zaktualizować jedynie te fragmenty interfejsu, które faktycznie uległy zmianie. Hook useState jest łatwy w użyciu, lecz odpowiedni głównie dla prostych przypadków, gdzie stan jest lokalny i nie wymaga udostępniania innym komponentom.

\begin{lstlisting}[language=tsx, caption={Example of local state management using the \texttt{useState} hook.}, label={lst:react-usestate}]
import { useState } from 'react';

function Counter() {
  const [value, setValue] = useState(0);

  const increment = () => {
    setValue(prev => prev + 1);
  };

  return (
    <button onClick={increment}>
      {value}
    </button>
  );
}
\end{lstlisting}

W bardziej złożonych scenariuszach wykorzystywany jest hook useReducer, który pozwala zarządzać stanem w sposób przypominający wzorzec Redux, oparty na zdefiniowanych akcjach i funkcji redukującej. Rozwiązanie to sprawdza się szczególnie w sytuacjach, gdy logika modyfikacji stanu jest złożona lub wymaga obsługi wielu różnych typów aktualizacji.

\begin{lstlisting}[language=tsx, caption={Using the \texttt{useReducer} hook for complex state update logic.}, label={lst:react-usereducer}]
import { useReducer } from 'react';

function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return state + 1;
    case 'reset':
      return 0;
    default:
      return state;
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, 0);

  return (
    <div>
      <button onClick={() => dispatch({ type: 'increment' })}>
        {state}
      </button>
      <button onClick={() => dispatch({ type: 'reset' })}>
        Reset
      </button>
    </div>
  );
}
\end{lstlisting}

W przypadku gdy stan musi być współdzielony pomiędzy wieloma komponentami, React oferuje mechanizm kontekstu (Context API). Pozwala on na przekazywanie danych pomiędzy odległymi elementami drzewa komponentów bez konieczności ręcznego przekazywania ich przez kolejne poziomy hierarchii. Mechanizm ten jest przydatny m.in. do obsługi ustawień aplikacji, motywów graficznych czy globalnych danych, jednak jego nadmierne stosowanie może prowadzić do niepotrzebnych renderów, jeśli struktura kontekstu nie została odpowiednio zaprojektowana.

\begin{lstlisting}[language=tsx, caption={Basic example of using the Context API for state sharing.}, label={lst:react-context}]
import { createContext, useState } from 'react';

export const AppContext = createContext({
  value: 0,
  setValue: (v) => {}
});

function AppProvider({ children }) {
  const [value, setValue] = useState(0);

  return (
    <AppContext.Provider value={{ value, setValue }}>
      {children}
    </AppContext.Provider>
  );
}
\end{lstlisting}

W przypadku dużych aplikacji lub projektów o skomplikowanej logice wymiany danych często stosowane są zewnętrzne biblioteki do zarządzania stanem, takie jak Redux, MobX lub Zustand. Redux opiera się na koncepcji pojedynczego źródła prawdy (store) oraz niezmienności danych, co zapewnia wysoki stopień przewidywalności i ułatwia debugowanie, lecz wymaga bardziej rozbudowanej konfiguracji. MobX z kolei stosuje podejście reaktywne, automatycznie monitorując zależności i aktualizując widok tylko tam, gdzie zaszły zmiany. Nowsze rozwiązania, takie jak Zustand, upraszczają zarządzanie stanem, wprowadzając prosty i deklaratywny interfejs oparty na hookach.

Zarządzanie stanem ma bezpośredni wpływ na wydajność aplikacji React. Niewłaściwie zaprojektowana struktura stanów lub nadmierne ich współdzielenie może prowadzić do wielokrotnych i niepotrzebnych renderów komponentów, co negatywnie wpływa na płynność działania interfejsu. Z tego względu niezwykle istotne jest świadome korzystanie z hooków, optymalizacja zakresu kontekstu oraz unikanie przechowywania danych globalnych, które nie muszą być dostępne we wszystkich komponentach. React oferuje również narzędzia umożliwiające optymalizację renderowania, takie jak useMemo, useCallback czy React.memo, które pozwalają ograniczyć liczbę aktualizacji poprzez zapamiętywanie wyników obliczeń lub renderów komponentów.

\begin{lstlisting}[language=tsx, caption={Example of component rendering optimization using \texttt{useMemo} and \texttt{React.memo}.}, label={lst:react-memo}]
import { memo, useMemo } from 'react';

const Result = memo(function Result({ items }) {
  const sum = useMemo(() => items.reduce((a, b) => a + b, 0), [items]);
  return <div>{sum}</div>;
});
\end{lstlisting}

Podsumowując, React dostarcza elastyczne mechanizmy zarządzania stanem, umożliwiające realizację zarówno prostych, jak i bardzo zaawansowanych scenariuszy. Wybór odpowiedniego podejścia zależy od wielkości i charakterystyki aplikacji, jednak świadome wykorzystanie dostępnych narzędzi ma kluczowe znaczenie dla utrzymania przejrzystości kodu oraz zapewnienia wysokiej wydajności renderowania interfejsu.

\subsection{Optymalizacja wydajności w aplikacjach React}
Wydajność renderowania jest jednym z kluczowych aspektów tworzenia aplikacji w React, szczególnie w przypadku interfejsów wymagających częstych aktualizacji stanu lub operujących na dużych zbiorach danych. Chociaż React dzięki mechanizmowi Virtual DOM ogranicza liczbę niezbędnych operacji na rzeczywistym drzewie DOM, to nadmierne i niekontrolowane renderowanie komponentów może nadal prowadzić do spadków płynności działania aplikacji. Z tego powodu React oferuje szereg narzędzi oraz wzorców umożliwiających optymalizację procesu renderowania i minimalizację liczby niepotrzebnych aktualizacji widoku.

Jednym ze sposobów optymalizacji jest wykorzystanie funkcji \texttt{React.memo}, która umożliwia zapamiętywanie wyników renderowania komponentów funkcyjnych. Jeśli przekazywane do komponentu właściwości nie uległy zmianie, React renderuje go ponownie wyłącznie wtedy, gdy jest to konieczne. Mechanizm ten jest szczególnie skuteczny w przypadku komponentów o dużej złożoności, które w przeciwnym razie byłyby aktualizowane przy każdej zmianie stanu ich komponentów nadrzędnych.

Drugim istotnym narzędziem są hooki \texttt{useMemo} oraz \texttt{useCallback}. Pierwszy z nich pozwala na zapamiętywanie wyników kosztownych obliczeń, dzięki czemu funkcja jest ponownie wykonywana tylko wtedy, gdy zmienią się wartości zależności. Z kolei \texttt{useCallback} umożliwia zapamiętanie referencji do funkcji, co zapobiega niepotrzebnemu przekazywaniu nowych instancji funkcji jako właściwości komponentów podrzędnych. Ma to szczególne znaczenie w sytuacjach, gdy komponenty podrzędne są opakowane w \texttt{React.memo} i reagują na zmiany referencji funkcji.

Optymalizacja może obejmować również odpowiednie zarządzanie strukturą stanu. Przechowywanie zbyt dużej liczby danych w stanie globalnym lub dzielenie się stanem pomiędzy zbyt wieloma komponentami prowadzi do nadmiarowych renderów. Z tego względu stan aplikacji powinien być możliwie jak najbardziej lokalny, a dane globalne należy wykorzystywać tylko wtedy, gdy faktycznie są współdzielone pomiędzy różnymi częściami interfejsu. Pomocne mogą być także techniki takie jak dzielenie komponentów na mniejsze elementy, aby ograniczyć zakres renderowania tylko do tych fragmentów, które faktycznie uległy zmianie.

W aplikacjach wymagających wysokiej wydajności warto również stosować mechanizmy kolejkowania i opóźniania aktualizacji, dostępne poprzez \texttt{useTransition} lub \texttt{useDeferredValue}. Funkcje te wprowadzono w wersjach Reacta wspierających renderowanie współbieżne (Concurrent Mode), co pozwala na priorytetyzowanie aktualizacji i zapewnia płynność interfejsu nawet w warunkach dużego obciążenia. Przykładowo, \texttt{useTransition} pozwala oznaczyć mniej priorytetowe operacje (np. odświeżenie wizualizacji algorytmu), dzięki czemu interakcje użytkownika (np. suwak prędkości) pozostają responsywne.

\begin{lstlisting}[language=tsx, caption={Using \texttt{useTransition} and \texttt{useDeferredValue} hooks to manage rendering priorities.}, label={lst:react-concurrent}]
import { useState, useTransition, useDeferredValue } from 'react';

function SortingVisualizer({ data }) {
  const [isPending, startTransition] = useTransition();
  const deferredData = useDeferredValue(data);

  const handleUpdate = (newData) => {
    startTransition(() => {
      // Lower priority operation
      setSortState(newData);
    });
  };

  return (
    <div style={{ opacity: isPending ? 0.8 : 1 }}>
      {/* Visualization based on deferred data */}
      <Bars items={deferredData} />
    </div>
  );
}
\end{lstlisting}

Oprócz narzędzi programistycznych React udostępnia także profiler, umożliwiający analizę czasu renderowania poszczególnych komponentów. Profilowanie jest kluczowym elementem optymalizacji, ponieważ pozwala precyzyjnie ustalić, które elementy interfejsu generują nadmiarowe aktualizacje lub wykonują kosztowne operacje podczas renderowania.

Podsumowując, React oferuje rozbudowany zestaw narzędzi wspierających optymalizację wydajności aplikacji, obejmujący zarówno kontrolę nad procesem renderowania komponentów, jak i zarządzanie stanem oraz strukturą aplikacji. Świadome stosowanie dostępnych mechanizmów, takich jak \texttt{React.memo}, \texttt{useMemo}, \texttt{useCallback} czy funkcje wspierające renderowanie współbieżne, jest kluczowe dla tworzenia płynnych i responsywnych interfejsów, szczególnie w projektach wymagających dynamicznych i częstych aktualizacji widoku.
\subsection{Integracja React z TypeScript}
Integracja React z TypeScript stanowi obecnie standardowe podejście do tworzenia nowoczesnych aplikacji frontendowych. TypeScript, jako nadzbiór JavaScriptu wprowadzający statyczne typowanie, pozwala na wykrywanie błędów już na etapie kompilacji oraz zapewnia większą kontrolę nad strukturą danych. W połączeniu z deklaratywnym i komponentowym charakterem Reacta umożliwia to zwiększenie czytelności kodu, łatwiejsze utrzymanie projektu oraz wyższą przewidywalność działania aplikacji.

TypeScript znajduje zastosowanie zarówno w definicjach propsów komponentów, jak i podczas opisywania struktur stanu, funkcji pomocniczych, interfejsów oraz modeli danych obsługiwanych przez aplikację. Dzięki temu programista ma możliwość precyzyjnego określenia typów przekazywanych pomiędzy komponentami, co znacząco ogranicza ryzyko wystąpienia błędów wynikających z niezgodności typów. Typowanie jest szczególnie istotne w aplikacjach o dużej liczbie komponentów lub rozbudowanym systemie zarządzania stanem.

Kluczowym elementem integracji Reacta z TypeScriptem jest użycie rozszerzenia TSX (TypeScript XML), które umożliwia łączenie składni TypeScriptu z deklaratywnym opisem komponentów Reacta. Pliki z rozszerzeniem \texttt{.tsx} pozwalają na stosowanie składni JSX wraz z pełnym wsparciem typów, co umożliwia definiowanie komponentów w sposób zbliżony do tradycyjnego JSX, ale z dodatkowymi możliwościami walidacji typów podczas kompilacji. TSX zapewnia również podpowiedzi składniowe (intellisense), ułatwia pracę z IDE oraz zwiększa czytelność kodu dzięki możliwości opisywania typów dla propsów, obiektów i funkcji bezpośrednio w definicji komponentu.

TypeScript wspiera także typowanie hooków Reacta, takich jak \texttt{useState}, \texttt{useReducer}, \texttt{useRef} czy \texttt{useMemo}, co umożliwia tworzenie bardziej przewidywalnych i stabilnych struktur stanu. Przykładowo, zdefiniowanie typu przechowywanej wartości w \texttt{useState} pozwala uniknąć nieprawidłowych aktualizacji lub błędów wynikających z niezgodności typów. Z kolei w przypadku kontekstu Reacta (Context API) możliwość typowania wartości przekazywanych pomiędzy komponentami ułatwia tworzenie skalowalnych aplikacji z jednoznacznie zdefiniowanymi strukturami danych.

Integracja z TypeScriptem wpływa również na proces budowy i utrzymania aplikacji. Kompilator TypeScriptu umożliwia wczesne wykrywanie błędów, co skraca czas debugowania oraz zwiększa bezpieczeństwo wdrażania kolejnych zmian. W większych projektach TypeScript poprawia współpracę zespołu przez jednoznaczne definiowanie interfejsów i kontraktów pomiędzy komponentami, co ogranicza ryzyko błędnej interpretacji danych lub nieprzewidzianych zmian w strukturze aplikacji.

Podsumowując, React w połączeniu z TypeScriptem stanowi wydajne i przewidywalne środowisko do tworzenia nowoczesnych aplikacji webowych. Integracja mechanizmów typowania, obsługi plików TSX oraz zaawansowanych narzędzi analizy statycznej pozwala na budowę skalowalnych i dobrze zorganizowanych projektów, w których elementy interfejsu oraz logika biznesowa są jasno zdefiniowane i łatwe do utrzymania.

\section{Ekosystem Angular i optymalizacja detekcji zmian}
Angular to kompleksowa platforma i framework programistyczny typu open source, rozwijany przez firmę Google, przeznaczony do budowy rozbudowanych, skalowalnych aplikacji webowych. W przeciwieństwie do Reacta, Angular oferuje pełny, zintegrowany ekosystem narzędzi (\textit{batteries-included approach}), dostarczając ustandaryzowane rozwiązania dla DI (Dependency Injection), obsługi formularzy, routingu oraz komunikacji asynchronicznej.

\subsection{Architektura komponentowa i nowoczesne mechanizmy reaktywności}
Architektura Angulara opiera się na hierarchii komponentów i ścisłej separacji logiki od widoku. Współczesny Angular (od wersji 17+) przeszedł rewolucję dzięki wprowadzeniu Sygnałów (\textit{Signals}). Sygnały pozwalają frameworkowi na precyzyjne śledzenie zależności (\textit{fine-grained reactivity}), co oznacza, że Angular wie dokładnie, która część szablonu zależy od której wartości stanu.

Tradycyjny model detekcji zmian oparty na \texttt{Zone.js} monitorował wszystkie asynchroniczne zdarzenia i sprawdzał całe drzewa komponentów. Podejście oparte na Sygnałach pozwala na budowę aplikacji typu \textit{Zoneless}, gdzie proces aktualizacji widoku jest wyzwalany tylko tam, gdzie faktycznie nastąpiła zmiana danych, co drastycznie redukuje narzut obliczeniowy w aplikacjach o wysokiej dynamice, takich jak wizualizery algorytmów.

\begin{lstlisting}[language=tsx, caption={State management in Angular using the Signals mechanism.}, label={lst:angular-signals}]
@Component({
  selector: 'app-visualizer',
  standalone: true,
  template: `<div>Value: {{ count() }}</div>`
})
export class VisualizerComponent {
  // Signal definition
  count = signal(0);
  
  // Computed value automatically updated
  doubleCount = computed(() => this.count() * 2);

  increment() {
    this.count.update(v => v + 1);
  }
}
\end{lstlisting}

Kluczową koncepcją organizacyjną do niedawna były moduły (\textit{NgModules}), które grupowały logicznie powiązane komponenty, dyrektywy, potoki i serwisy. Moduły pozwalały na precyzyjne zarządzanie widocznością elementów oraz optymalizację procesu ładowania aplikacji poprzez technologię \textit{lazy loading}. W najnowszych wersjach frameworka wprowadzono tzw. \textit{Standalone Components}, które upraszczają architekturę, eliminując konieczność definiowania modułów dla każdego elementu, co redukuje tzw. \textit{boilerplate code}.

Fundamentalnym mechanizmem Angulara, determinującym jego wydajność, jest system detekcji zmian (\textit{Change Detection}). Framework monitoruje stan aplikacji i automatycznie aktualizuje widok, gdy wykryje zmiany w modelach danych. Przez lata mechanizm ten opierał się na bibliotece \textit{Zone.js}, która monitoruje asynchroniczne zdarzenia i uruchamia proces sprawdzania całego drzewa komponentów. Rewolucją jest wprowadzenie mechanizmu \textit{Signals} (Sygnałów), który pozwala frameworkowi na precyzyjne śledzenie zależności. Sygnały informują Angulara dokładnie o tym, która część szablonu wymaga odświeżenia, co umożliwia budowę aplikacji typu \textit{Zoneless}, znacząco redukując narzut obliczeniowy, szczególnie w aplikacjach z dużą liczbą dynamicznych aktualizacji, takich jak wizualizery algorytmów.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.85\textwidth]{images/angular-change-detection.png}
    \caption{Tradycyjny model detekcji zmian w Angularze oparty na Zone.js (sprawdzanie od góry drzewa).}
    \label{fig:angular-cd}
\end{figure}

\subsection{Zarządzanie stanem w Angular}
Zarządzanie stanem w Angularze jest nierozerwalnie związane z programowaniem reaktywnym i biblioteką RxJS. Framework ten promuje model asynchronicznego przepływu danych, gdzie serwisy pełnią rolę "magazynów stanu". Wykorzystują one obiekty typu \texttt{Subject} lub \texttt{BehaviorSubject} do emitowania aktualnych wartości, które są konsumowane przez komponenty za pomocą subskrypcji.

Podejście oparte na RxJS pozwala na potężną manipulację strumieniami danych poprzez operatory takie jak \texttt{map}, \texttt{filter} czy \texttt{switchMap} \cite{RxJS_Action}. Jest to kluczowe w wizualizatorach algorytmów, gdzie kroki sortowania mogą być emitowane jako strumień, który następnie jest "spowolniany", aby zapewnić czytelną animację.

\begin{lstlisting}[language=tsx, caption={Example of an advanced service in Angular using RxJS for visualization state management.}, label={lst:angular-service-v2}]
@Injectable({ providedIn: 'root' })
export class SortingStateService {
  private barsSubject = new BehaviorSubject<number[]>([]);
  bars$ = this.barsSubject.asObservable();

  updateState(newBars: number[]) {
    this.barsSubject.next([...newBars]);
  }
}
\end{lstlisting}

Nowoczesny Angular wprowadza Sygnały jako alternatywę dla stanu synchronicznego. Sygnały eliminują potrzebę ręcznego zarządzania subskrypcjami i oferują naturalną składnię dla operacji takich jak obliczanie wartości pochodnych (\texttt{computed}) czy wywoływanie efektów (\texttt{effect}). W bardzo dużych aplikacjach stosuje się NgRx, który implementuje wzorzec Redux, zapewniając pełną przewidywalność zmian stanu i ułatwiając debugowanie.

\subsection{Optymalizacja wydajności w aplikacjach Angular}
Wydajność w Angularze zależy przede wszystkim od efektywności procesu detekcji zmian. Kluczową techniką jest strategia \texttt{OnPush} (\textit{ChangeDetectionStrategy.OnPush}), która instruuje framework, aby sprawdzał komponent tylko wtedy, gdy zmienią się referencje jego wejściowych właściwości (\texttt{@Input()}) lub zostanie wyemitowane zdarzenie. Zastosowanie \texttt{OnPush} w połączeniu z niezmiennością danych (\textit{immutability}) pozwala na drastyczne zredukowanie liczby operacji detekcji zmian, co jest krytyczne dla zachowania płynności animacji w wizualizatorze.

Inne techniki optymalizacji obejmują:
\begin{itemize}
    \item \textbf{Kompilator Ivy:} Generuje mniejsze pakiety danych dzięki mechanizmowi \textit{tree-shaking} oraz przyspiesza proces uruchamiania aplikacji.
    \item \textbf{TrackBy:} Podczas renderowania list, funkcja \texttt{trackBy} pozwala Angularowi zidentyfikować, które elementy DOM odpowiadają rekordom w danych, unikając niszczenia i ponownego tworzenia całego DOM-u przy każdej zmianie w tablicy.
    \item \textbf{Deferrable Views:} Nowa funkcja umożliwiająca deklaratywne opóźnianie ładowania i renderowania fragmentów szablonu do czasu, gdy np. stają się widoczne na ekranie (\textit{viewport visibility}).
    \item \textbf{Pure Pipes:} Stosowanie czystych potoków, które są uruchamiane tylko wtedy, gdy ich wejście ulegnie zmianie, co oszczędza cykle procesora na transformacje danych.
\end{itemize}

\subsection{Angular i TypeScript – natywna integracja}
Angular to framework zbudowany "przez TypeScript i dla TypeScripta". To partnerstwo zaowocowało modelem programowania, w którym cechy języka są fundamentem działania frameworka. Wszystkie kluczowe mechanizmy — komponenty, serwisy, moduły — są definiowanymi jako klasy TypeScript z dekoratorami (np. \texttt{@Component}, \texttt{@Injectable}). Dekoratory dołączają metadane do klas, informując kompilator o ich przeznaczeniu, co pozwala na wyraźne oddzielenie konfiguracji od logiki biznesowej.

Statyczne typowanie w Angularze przynosi korzyści w postaci:
\begin{itemize}
    \item \textbf{Type-safe Dependency Injection:} System DI wykorzystuje typy parametrów w konstruktorze do identyfikacji zależności, co zapobiega błędom w czasie uruchomienia.
    \item \textbf{Strict Template Checking:} Kompilator Angulara potrafi sprawdzić poprawność typów wewnątrz szablonów HTML, co drastycznie redukuje liczbę błędów typu \textit{undefined}.
    \item \textbf{Zaawansowane narzędzia IDE:} Dzięki statycznej analizie kodu, deweloperzy mogą korzystać z błyskawicznej nawigacji i automatycznej refaktoryzacji nawet w bardzo rozbudowanych projektach.
\end{itemize}

Podsumowując, natywna integracja z TypeScriptem sprawia, że Angular jest frameworkiem wyjątkowo stabilnym i skalowalnym, idealnym do budowy złożonych systemów wymagających wysokiej precyzji i wydajności.

\section{Podstawy algorytmów sortujących i ich wizualizacji}
Algorytmy sortowania stanowią jeden z fundamentalnych obszarów informatyki, służąc do porządkowania elementów w zbiorze według określonej relacji \cite{Cormen_Intro}. W kontekście niniejszej pracy pełnią one rolę generatora intensywnego obciążenia dla silników renderujących, ponieważ proces ich wykonywania wiąże się z sekwencją licznych porównań i zamian miejsc elementów zbioru.

\subsection{Klasyfikacja i charakterystyka wybranych algorytmów sortujących}
Algorytmy sortujące można klasyfikować według wielu kryteriów, z których najważniejszymi są złożoność czasowa oraz stabilność. Złożoność czasowa określa, jak czas wykonania algorytmu rośnie wraz ze wzrostem liczby elementów ($n$). Wyróżniamy złożoność optymistyczną, średnią oraz pesymistyczną, przy czym ta ostatnia jest kluczowa dla określenia granic wydajności systemu.

Kolejnym ważnym parametrem jest złożoność pamięciowa (\textit{space complexity}), określająca ilość dodatkowej pamięci potrzebnej do wykonania operacji. Algorytmy działające w miejscu (\textit{in-place}) są preferowane w środowiskach o ograniczonych zasobach, takich jak przeglądarki mobilne. Stabilność algorytmu natomiast informuje o tym, czy zachowuje on relatywną kolejność elementów o tych samych kluczach, co może być istotne przy sortowaniu obiektów o wielu atrybutach.

W pracy wybrano reprezentatywne algorytmy o różnej charakterystyce wydajnościowej i architektonicznej:
\begin{itemize}
    \item \textbf{Sortowanie bąbelkowe (Bubble Sort):} Jeden z najprostszych algorytmów iteracyjnych o złożoności $O(n^2)$. Choć nieefektywny dla dużych zbiorów, jest idealny do demonstracji mechanizmów detekcji zmian ze względu na bardzo regularną strukturę operacji zamiany (\textit{swap}). W wizualizacji pozwala on na obserwację "wypływania" największych elementów na koniec tablicy, co jest czytelne dla użytkownika, ale obciążające dla renderera przez dużą liczbę drobnych aktualizacji.
    \item \textbf{Sortowanie przez wstawianie (Insertion Sort):} Algorytm o złożoności $O(n^2)$, który buduje posortowaną część tablicy, wstawiając do niej kolejne elementy. W przeciwieństwie do Bubble Sort, znacznie rzadziej wykonuje operacje zamiany miejsc, co pozwala na porównanie, jak frameworki radzą sobie z przesuwaniem większych bloków danych w strukturze DOM.
    \item \textbf{Sortowanie szybkie (Quick Sort):} Algorytm typu "dziel i zwyciężaj" o złożoności średniej $O(n \log n)$. Wykorzystuje element osiowy (pivot) do partycjonowania tablicy. Z punktu widzenia wizualizacji jest on wyzwaniem, ponieważ operacje następują w różnych, często odległych od siebie miejscach tablicy, co wymusza na silnikach renderujących częste zmiany w rozproszonych gałęziach drzewa widoku. Jest on kluczowy do testowania wydajności przy operacjach o wysokiej dynamice.
    \item \textbf{Sortowanie przez scalanie (Merge Sort):} Algorytm o stabilnej złożoności $O(n \log n)$, który rekurencyjnie dzieli zbiór na mniejsze części i scala je w uporządkowany sposób. Merge Sort wymaga dodatkowej pamięci ($O(n)$), co w wizualizatorze często wiąże się z koniecznością wyświetlenia "tablic pomocniczych" lub animowania procesu kopiowania danych. Pozwala to na testowanie wydajności renderowania przy dynamicznym tworzeniu i niszczeniu elementów interfejsu.
    \item \textbf{Sortowanie stogowe (Heap Sort):} Algorytm wykorzystujący strukturę kopca binarnego o złożoności $O(n \log n)$. Jego wizualizacja jest specyficzna, ponieważ wymaga odwzorowania liniowej tablicy jako struktury drzewiastej. Pozwala to na analizę, jak frameworki radzą sobie z prezentacją tych samych danych w dwóch różnych formach graficznych jednocześnie.
\end{itemize}

\begin{lstlisting}[language=tsx, caption={Skeleton of an asynchronous sorting algorithm (Bubble Sort) prepared for visualization.}, label={lst:algo-skeleton}]
async function bubbleSort(array: number[], update: (arr: number[]) => void) {
  const n = array.length;
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n - i - 1; j++) {
      if (array[j] > array[j + 1]) {
        // Swap elements
        [array[j], array[j + 1]] = [array[j + 1], array[j]];
        
        // State update and forcing a break for the renderer
        update([...array]);
        await new Promise(resolve => setTimeout(resolve, 10));
      }
    }
  }
}
\end{lstlisting}

\subsection{Metody wizualizacji algorytmów}
Wizualizacja algorytmów sortowania w aplikacjach webowych sprowadza się do graficznej reprezentacji elementów zbioru (najczęściej jako słupków o różnej wysokości, gdzie wysokość odpowiada wartości elementu) oraz dynamicznej aktualizacji ich wyglądu w czasie rzeczywistym.

Efektywna wizualizacja musi uwzględniać nie tylko techniczne aspekty renderowania, ale również percepcję użytkownika. Oznacza to konieczność wprowadzenia opóźnień (\textit{delays}) między krokami algorytmu, aby proces był widoczny dla ludzkiego oka, przy jednoczesnym zachowaniu płynności animacji przejść.

Istnieją dwie główne architektury synchronizacji logiki algorytmu z widokiem:
\begin{itemize}
    \item \textbf{Podejście oparte na migawkach (Snapshot-based):} Algorytm jest wykonywany w izolacji od warstwy widoku, a każdy jego "krok" (porównanie, zamiana) jest zapisywany jako stan tablicy w dedykowanej kolejce (historii ruchów). Po zakończeniu obliczeń, framework odtwarza historię, renderując stany jeden po drugim z określonym interwałem. Metoda ta gwarantuje stabilność interfejsu, ale opóźnia rozpoczęcie wizualizacji do zakończenia obliczeń, co przy rekordowo dużych zbiorach może być odczuwalne.
    \item \textbf{Podejście asynchroniczne w czasie rzeczywistym (Real-time Async):} Algorytm jest wykonywany bezpośrednio w głównej nitce (lub w Web Workerze), a po każdej operacji następuje asynchroniczne przerwanie (\texttt{await sleep(ms)}). Podczas tej pauzy, stan jest aktualizowany w frameworku, co wyzwala natychmiastowe renderowanie. Jest to podejście bardziej zbliżone do rzeczywistych aplikacji interaktywnych i pozwala na testowanie reaktywności frameworka pod ciągłym obciążeniem.
\end{itemize}

Wizualizacja wymaga również precyzyjnego zarządzania atrybutami graficznymi. Kluczowe jest oznaczanie kolorami:
\begin{itemize}
    \item \textbf{Wybór i porównanie:} Elementy aktualnie porównywane są zazwyczaj wyróżniane kontrastowym kolorem (np. czerwonym).
    \item \textbf{Zamiana:} Elementy zmieniające pozycję mogą pulsować lub zmieniać nasycenie koloru.
    \item \textbf{Uporządkowanie:} Fragmenty tablicy, które algorytm uznał za ostatecznie posortowane, są oznaczane kolorem "bezpiecznym" (np. zielonym).
\end{itemize}
Płynność tych zmian jest determinowana przez to, jak szybko framework potrafi zidentyfikować zmienione atrybuty CSS (komponentów lub elementów DOM) i przesłać je do silnika kompozycji przeglądarki. Optymalizacja tych przejść (np. poprzez użycie \textit{CSS Transitions} lub \textit{Transforms} zamiast zmiany szerokości/pozycji \textit{top/left}) jest niezbędna dla uniknięcia zjawiska \textit{layout thrashing}.

W dalszej części pracy, oba te podejścia zostaną zaimplementowane i poddane testom obciążeniowym, co pozwoli na ocenę, jak architektura Reacta (Virtual DOM) oraz Angulara (Signals/OnPush) radzi sobie z zarządzaniem setkami dynamicznie zmieniających się obiektów graficznych.


\chapter{Metodyka badań i implementacja aplikacji}

\section{Założenia projektowe i wymagania funkcjonalne dla wizualizatora algorytmów}
Głównym założeniem projektowym platformy badawczej jest stworzenie dwóch funkcjonalnie identycznych aplikacji, które umożliwią obiektywne porównanie wydajności renderowania w frameworkach React i Angular. Wizualizator musi sprostać wyzwaniu płynnego wyświetlania setek operacji na danych przy zachowaniu wysokiej interaktywności interfejsu.

Do kluczowych wymagań funkcjonalnych zaliczono:
\begin{itemize}
    \item \textbf{Wielowątkowość logiczna:} Możliwość jednoczesnej wizualizacji wielu algorytmów (Bubble Sort, Quick Sort, Merge Sort, Heap Sort) w celu porównania ich dynamiki pracy.
    \item \textbf{Sterowanie czasem rzeczywistym:} Użytkownik musi mieć możliwość płynnej regulacji prędkości animacji (opóźnienia między krokami) w zakresie od 50 ms do 600 ms.
    \item \textbf{Interaktywność:} Możliwość wstrzymywania (Pause), wznawiania (Play), restartowania oraz losowania nowych danych (Shuffle) bez konieczności przeładowywania aplikacji.
    \item \textbf{Precyzja wizualna:} Wyraźne rozróżnienie stanów elementów poprzez kolory: porównywanie (amber), zamiana (red), oś podziału/pivot (blue) oraz elementy posortowane (emerald).
    \item \textbf{Responsywność:} Interfejs wykonany w podejściu \textit{Responsive Web Design}, zapewniający czytelność wizualizacji zarówno na ekranach desktopowych, jak i urządzeniach mobilnych.
\end{itemize}

Projekt techniczny zakłada wykorzystanie TypeScriptu jako nadrzędnego języka programowania, co zapewnia spójność typów pomiędzy logiką algorytmów a komponentami interfejsu użytkownika.

\section{Opis implementacji aplikacji wizualizującej w React}
Aplikacja w wersji React została zbudowana z wykorzystaniem najnowszych standardów biblioteki (wersja 19) oraz nowoczesnych narzędzi ekosystemu JavaScript.

\subsection{Struktura projektu i kluczowe komponenty}
Architektura aplikacji opiera się na separacji logiki biznesowej od warstwy prezentacji. Główne elementy struktury to:
\begin{itemize}
    \item \textbf{Routy aplikacji:} Wykorzystanie React Router v7 do obsługi nawigacji między stroną powitalną (\textit{Landing Page}) a głównym panelem badawczym (\textit{Dashboard}).
    \item \textbf{Komponenty UI:} Zastosowanie modułowej biblioteki komponentów (opartej na Tailwind CSS), co zapewnia spójność wizualną i szybki czas budowy interfejsu.
    \item \textbf{SortingProgressChart:} Centralny komponent wizualizacji, odpowiedzialny za renderowanie słupków danych z wykorzystaniem biblioteki Recharts.
\end{itemize}

\subsection{Wykorzystane biblioteki i narzędzia}
W projekcie wykorzystano następujący stos technologiczny:
\begin{itemize}
    \item \textbf{Vite:} Jako szybki system budowania i serwer deweloperski.
    \item \textbf{Tailwind CSS v4:} Do stylizacji z wykorzystaniem nowoczesnych funkcji takich jak \textit{glassmorphism} i zaawansowane gradienty.
    \item \textbf{Lucide React:} Zbiór ikon do elementów sterujących.
    \item \textbf{Recharts:} Do efektywnego renderowania wykresów słupkowych przy częstych aktualizacjach stanu.
\end{itemize}

\subsection{Podejście do zarządzania stanem}
Zarządzanie stanem wizualizacji zrealizowano za pomocą autorskiego hooka \texttt{useSorting}. Implementacja opiera się na podejściu opartym na migawkach (\textit{Snapshot-based}). Algorytmy generują listę kroków (\texttt{SortStep}), gdzie każdy krok zawiera aktualny stan tablicy oraz informacje o porównywanych indeksach.

\begin{lstlisting}[language=tsx, caption={Interface structure describing a visualization step in React.}, label={lst:react-step-interface}]
export type SortingProgress = {
  values: number[];
  comparing?: number[];
  swapping?: number[];
  pivot?: number | null;
  sorted?: number[];
}
\end{lstlisting}

Hook \texttt{useSorting} zarządza indeksem aktywnego kroku oraz interwałem czasowym za pomocą \texttt{window.setInterval}, co pozwala na odseparowanie tempa animacji od szybkości renderowania samej biblioteki React.

\subsection{Specyficzne techniki optymalizacyjne}
Aby zapewnić płynność wizualizacji przy setkach aktualizacji na sekundę, zastosowano następujące techniki:
\begin{itemize}
    \item \textbf{React.memo:} Komponent \texttt{SortingProgressChart} został opakowany w \texttt{memo}, dzięki czemu nie jest on renderowany ponownie, jeśli dane wizualizacji nie uległy zmianie.
    \item \textbf{useMemo dla zbiorów danych:} Indeksy porównywane i zamieniane są konwertowane na obiekty typu \texttt{Set} za pomocą \texttt{useMemo}. Pozwala to na uzyskanie złożoności $O(1)$ przy sprawdzaniu koloru każdego słupka podczas renderowania.
    \item \textbf{Separacja logiki:} Obliczanie wszystkich kroków algorytmu odbywa się przed rozpoczęciem animacji, co odciąża główny wątek podczas procesu renderowania.
\end{itemize}

\section{Opis implementacji aplikacji wizualizującej w Angular}
\subsection{Struktura projektu i moduły}
\subsection{Wykorzystane biblioteki i narzędzia}
\subsection{Podejście do zarządzania stanem}
\subsection{Specyficzne techniki optymalizacyjne}

\section{Metody i procedury pomiarowe dla analizy wydajności}

\section{Metody oceny produktywności programistycznej}


\chapter{Prezentacja i analiza wyników badań}

\section{Wyniki pomiarów wydajności renderowania dla obu implementacji}

\section{Analiza zużycia zasobów i płynności animacji}

\section{Porównanie rozmiarów i złożoności pakietów}

\section{Wyniki oceny łatwości rozwoju i produktywności programistycznej}

\section{Porównawcza analiza zastosowania TypeScript w obu frameworkach}


\chapter{Dyskusja wyników, wnioski i rekomendacje}

\section{Odpowiedzi na główne i szczegółowe pytania badawcze}

\section{Porównanie mocnych i słabych stron React i Angular w kontekście dynamicznych wizualizacji}

\section{Implikacje praktyczne dla deweloperów i architektów}

\section{Implikacje teoretyczne dla inżynierii oprogramowania}

\section{Ograniczenia przeprowadzonego badania}

\clearpage
\phantomsection
\addcontentsline{toc}{chapter}{Bibliografia}
\renewcommand{\bibname}{Bibliografia}
\bibliographystyle{unsrt}
\bibliography{references}
\end{document}
